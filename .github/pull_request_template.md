> 브랜치별로 PR을 했어야 했는데,, 모두 main을 기준으로 작성하였습니다..
> main 브랜치에 있는 코드 위주로 봐주시면 감사하겠습니다..

---
### **커밋 링크**

#### 단위 테스트

1) Mock 테스트 
   - 포인트 조회/충전 기능 초기 완성 : [[72eec80](https://github.com/HangHae-Study/week_1/tree/72eec80e2084b8c313cd6abe8c2784bb60355d3e)]
   - 유저 구분 별 포인트 조회/충전 테스트 : [[dc42650](https://github.com/HangHae-Study/week_1/tree/dc42650967ac6703bdd549505f4f5f52c35f752c)]
   - 포인트 사용 기능 완성 :[[ff7966a](https://github.com/HangHae-Study/week_1/tree/ff7966ab310876fa25df8e493d04a9c4e02b3e92)]


2. 고전파 테스트 
   - 실제 객체 사용 테스트 : [[5bbb55c](https://github.com/HangHae-Study/week_1/tree/5bbb55cbd2f057ece037cec692738f242e2b7e4a)]
   - 포인트 기록(history) 테스트 : [[15f2e98](https://github.com/HangHae-Study/week_1/tree/15f2e98c2ad62ecdd4974338ea7c74b7653d999d)]

#### 통합 테스트

1. 조회 컨트롤러 테스트
   - 초본 : [[40b2f5e](https://github.com/HangHae-Study/week_1/tree/40b2f5e920c5f63331bd9134d697ea6af913edcf)]
   - 완성 : [[9946b0c](https://github.com/HangHae-Study/week_1/tree/9946b0ce7dcb024a033fd5f358c9a5970675e2d1)]


2. 사용/충전 컨트롤러 테스트
   - [[93d5e7b](https://github.com/HangHae-Study/week_1/tree/93d5e7b021f820f9071088c490f77c3154c76100)]
---

## **리뷰 포인트(질문)**

### 리뷰 포인트 1
> PointService를 테스트하면서 아래 고민이 있습니다.
- 문제상황
    - `userPointTable.selectById(..)` 를  Mock 처리하려 했지만, 해당 메서드 내부에서는 `Map.getOrDefault(..)`로 empty 객체를 리턴하는 로직이 존재합니다.
    - 아래처럼 Stub으로 설정했지만, 도메인 규칙이 바뀐다면 이 부분이 깨질 가능성이 있다고 생각합니다.
      ```
      Long id = 1L;
      UserPoint mockUser = new UserPoint(id, 0L, 0L);
      given(userPointTable.selectById(id)).willReturn(mockUser);
      
      Long userId = 1L;
      UserPoint emptyUser = UserPoint.empty(userId);
      given(userPointTable.selectById(userId)).willReturn(emptyUser);
      ```
        - (Parameter가 추가되거나, empty를 뱉지 않게 된다면..?)
        - (하지만, 위 방법말고는 도저히 다른 방법이 떠오르질 않습니다..)


- 의문 사항
    - 위 두 가지 Mock 방식에서, 내부 로직의 변경에 자유롭고, 결합력이 낮은 Stub을 작성할 수 있는 다른 방안이 혹시 존재할까요?
        - 블랙박스 테스트라면 Table 내부가 empty 객체를 리턴한다는 사실도 몰라야 할까요?
        - 아니면 Table이 empty를 반환한다는 전제 정도는 알고 테스트 Stub을 만드는 게 맞을까요?
          <br/><br/>
    - Table 클래스가 그대로 유지된다는 전제에서 테스트를 짠다면 어느 범위까지 블랙 박스의 범주에 포함 시켜야할지 경계 설정 방법이 따로 있을지 궁금합니다.
        - Service 단위의 내부 동작을 모른채로 테스트하는 것이 맞는지?
        - Table 단위의 내부 동작을 모른채로 테스트하는 것이 맞는지?
        - Table 까지 실제로 연동한 통합 테스트로 가져가야 할지?
          <br/><br/>
    - 저는, 포인트 테이블에 대한 동작까지 이미 숙지한 채로 테스트 코드를 작성했습니다. <br/>
      >-> Point 내부에 대한 동작이 곧 서비스에서 포인트 테이블을 호출하는 행위 대부분이 귀결되는 행위일텐데,,,
        - 이 범위에서 블랙 박스라 함은 발생할 수 있는 "예외" 혹은 비즈니스/도메인에 대한 제약 사항을 미리 설정하는 부분으로 바라봐도 될까요?
        - ex)
            - 음수 단위의 포인트를 충전할 수 없다
            - 현재 포인트보다 더 많은 포인트를 사용할 수 없다
            - 포인트 기록의 응답 데이터 단위는 배열이다 (배열 안의 값은 모름)
              <br/><br/>
    - 비즈니스 규칙(ex. 음수 충전 불가, 초과 사용 불가)을 어디까지 Mock/Stub으로 커버해야 할까요?
        - Table stub으로 처리할지
        - Service 내부에서 검증할지



멘토님께서는 이런 상황에서 테스트의 블랙박스 범위를 어디까지 잡으시는지 궁금합니다.

<br/>

###  리뷰 포인트2
```
    @Test
    void T1_유저의_포인트_조회를_요청한다() throws Exception{

        Long userId = 1L;
        pointService.charge(userId, 400L);

        mockMvc.perform(get("/point/{id}", userId))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.code").value("SUCCESS"))
                .andExpect(jsonPath("$.data.id").value(userId))
                .andExpect(jsonPath("$.data.point").value(400));
    }
```

해당 테스트에서는 응답 데이터에 대한 필드를 미리 숙지하고 있습니다.<br/>
블랙 박스 테스트는 내부 동작에 대한 숙지는 정확히 하지 않지만, 응답에 대해서는 요청하는 입장에서 이렇게 필드를 알아도 되는지??


만일에 내부 필드가 바뀐다면,, 그건 명세 자체가 바뀌는 것이기에 테스트 코드도 적절히 바뀌는 것이 당연한건지 궁금합니다. (저는 맞다고 생각해요.)
```
@Test
void T3_등록되지_않은_유저의_포인트_기록을_조회한다() throws Exception{
Long userId = 1L;

        mockMvc.perform(get("/point/{id}/histories", userId))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.code").value("SUCCESS"))
                .andExpect(jsonPath("$.data.length()").value(0));

        // 길이가 0 이다는 뭔가 내부에 결과가 나올 수 있다는 것을 암시하는 것 같음..
        // 0으로 만들지 말고,, data가 배열로 떨어진다는 사실만 안 채로, 집계한 값이 0인지를 판별한다면?
        // 근데 집계한 값이 0일 경우 포인트를 다 쓴 경우도 있음..
        // 그럼 배열이 떨어진 다는 사실을 알았을 때, 길이를 0으로 판별하는 것이 어찌하였건 테스트를 유효하게 만들 수 있는 조건 같음..

        // 배열 안에 뭐가 들어올진 모르고, 배열이라서 길이를 가진다는 것만 아는 것은 ? 화이트 or 블랙인가?
        // 배열 안에 데이터가 바뀌더라도, 배열이란 성질은 histories라는 공통의 기록 목록을 도메인으로 가져간다면, 길
        // 이를 바라보는 것은 비즈니스에 영향을 받지 않고, 도메인에 종속적이므로 블랙박스로 봐도 될듯한데??
    }
```
해당 코드 안의 주석 내용이 기록이 배열로 들어온다는 것만 인지하고, 내부객체가 어떤 형태를 띌지는 모른다는 전제를 잡았는데,,, 이또한 어디까지 블랙박스의 범위로 잡아야할지.. 알려주시면 감사하겠습니다.

- ControllerChargeUsePointTest 같은 경우, 코드를 모두 완성하고 단위테스트를 작성했다고 생각하는데, TDD 관점에서 필요한 테스트 클래스인지 의문이 듭니다..

---
### **이번주 KPT 회고**

### Keep
- 팀 원들과 궁금한 점들을 미리 정리하고 공유하면서, 인사이트를 얻을 수 있어 좋습니다.
- 팀 원들의 좋은 질문과, 정말 좋으신 코치님의 멘토링으로 궁금했던 점과 새로운 점들을 알아갈 수 있어서 정말 좋은 시간이었습니다.


- 테스트 코드는 개념만 알고, 쉽게 짜기 어려운 하나의 주제로 생각 했었는데, 직접 접해보니 실제로도 그러하였고 명세와 검증, 에러 발생시에 대응할 수 있는 하나의 도구로써 정말 좋은 무기가 될 수 있다는 생각을 하였습니다.


- 생각 정리를 하면서 /노트/~ 경로에 코드를 짜기 위한 준비를 글로 작성하였습니다.
  - 과제 제출 마감 직전에 다시 읽어보니,, 짧은 일주일동안 필요한 고민보다는 다소 부족한 고민을 더 많이했던 것 같네요..
  - 그래도 코드 작성에 대한 이유를 스스로 작성하면서, 계속해서 회고하고 다음 방향을 지속적으로 고민해볼 수 있었습니다.
  - 교육 수료 시에 썻던 글들을 다시 읽어보며, 어떻게 성장했을지 비교할 수 있는 하나의 수단이라고 생각하여 앞으로 10주동안 계속해서 작성해볼 예정입니다. (대신 코드와 과제 기능 완성에 더 비중을 두기.)


- 멘토링 받은 내용과 추가적으로 공부한 내용을 정리하여, 복습 준비도 할 예정입니다.

### Problem
- 과제 제출을 하기 위해 짰던 코드들을 다시 확인해보고, 정리했던 글을 다시 읽어보니,,
- `TDD를 연습해야한다, 테스트 코드를 짜자!` 라는 생각으로 급한 마음에 조금 더 코드를 들여다 보지 않고, 무작정 달려들었던 것 같습니다.


- 프론트에서 당연히 유저의 현재 포인트가 조회될 것이고, 그에 따른 후속 동작으로 충전/조회를 고민하였습니다.
- 그렇다보니 포인트가 0 점 일 때, Table 클래스에 존재하는 Map 필드의 getOrDefault 라는 메서드에 꽂혀, 
  - 포인트가 0일 경우, `기존에 존재하지 않던 UserPoint`인지, `포인트를 다 사용한 UserPoint`인지를 꼭 판별 해야겠다는 생각으로 코드를 작성하게 되었던 것 같습니다.


- 이 사실을 안 채로 테스트 코드를 작성하다보니, 과제에서 요구하는 블랙박스 테스트 보다는 화이트박스 테스트의 방향으로 작성할 수 밖에 없었던 것 같습니다..
- 이후, 멘토링을 통해서 코치님이 알려주신 여러 접근 방식과 예시를 보고, `selectById`가 뭘 하든, 테이블 함수를 호출하는 `poitnService`의 동작에 상관없이 테스트 코드가 통과될 수 있도록 작성하는 것이 좀 더 중요하겠다는 생각이 들었습니다.


- 단위 테스트 때에는 @Mock 객체와 Stub을 통해서 내부 동작을 이미 아는채로, 결합력이 높은 테스트를 작성하며 단위 테스트와 기능을 만드는데 초점을 두었지만..


- 조회/사용/충전의 모든 행위가 연결되어있는 `/point/{id}/histories` 기능을 구현할때는 Classic(고전파) 테스트를 지향하는 방향으로, 실제 객체를 사용하되 내부 객체의 비즈니스/도메인 자체의 기능이 바뀌지 않는다는 가정하에 통합테스트를 작성하려 노력 했습니다.

  (틀린 방법일 수 있지만...)

### Try

- 멘토링 시간에 받은 피드백을 기반으로, 내가 짠 코드에서는 어떤 문제가 있었는지 금요일 과제 제출 마감이후 빠르게 진행해 볼 예정입니다.
- 특히나 첫주 답게 상대적으로 수월한 주제(?)와 과제에 비해, 차주부터 더 어려운 내용이 있을 것이기 때문에, 주어진 과제와 공부 범위뿐만 아니라 여러 방법을 통해서 공부를 진행할 예정입니다.


- throttle과 관련하여 sleep 상황 발생시, 여러 API가 한 번에 요청 되었을 때 과연 updateTimeMillis가 정상적인 순서와 값을 가질지 궁금하여 추가적인 테스트 코드 작성을 통해, 과제에 의도된 요구사항들을 다 만족할 수 있도록 하는 것이 목표입니다.
- 팀원 들의 조각 코드를 보고, 제 코드를 비교하니... 객체 지향적으로 많이 떨어지는 코드라고 생각하여 기본기도 다시 공부를 꾸준히 해야겠습니다 .. 