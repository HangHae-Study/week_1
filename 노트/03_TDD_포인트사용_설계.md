### 테이블 구조 되짚어보기

- PointHistory `포인트 충전/사용 내역`
    - ID (히스토리 테이블 식별자)
    - 유저 ID (포인트 충전한 유저 식별자)
    - 충전량 (충전 포인트 금액)
    - 트랜잭션 타입 (충전 : CHARGE, 사용 : USE)
    - 변경 시간 (Milli초)


- UserPoint `유저가 가진 포인트`
    - ID : 유저 ID
    - 포인트 : 현재 유저가 가지고 있는 포인트 금액
    - 변경 시간 (Milli초)

'

> #### 유저의 사용 꼭지점에 대해서 고민을 해보자면,
1. 포인트가 0원 일 때
   - 포인트 사용을 할 수 없다.


2. 포인트가 0원이 아닐 때
   - 포인트가 사용하려는 포인트가 많다면, 포인트를 쓴 다.
   - 포인트가 사용하려는 포인트보다 적다면, 포인트를 쓸 수 없다.
     - (포인트가 0원일 때랑 똑같음)

  '
> #### throttle(sleep 시간)에 따른, 추가 확장 가능성?
1. 같은 사용 요청이 동시에 두번 들어 온다면?
   - 같은 사용 요청인지 판별할 기준이 필요하고, 그 기준에 따라 한번만 수행되도록 보장할 필요가 있다.


2. 충전이 아직 완료 되지 않았는데, 사용 요청이 들어온다면??
   - 각 충전/사용 단계가 명확하게 구분되어 테이블에 값이 올바르게 반영되어야한다.


3. 또는, 충전 금액이 충분할 때, 서로 다른 사용 요청이 여러번 온다면 모든 기능이 동작 완료된 후, 올바른 사용 금액과 잔여금액이 Table에 반영되도록 한다.
---

### 테스트 시나리오 생각해보기
1. 그렇다면, 사용에 성공했을 때는 서비스에서 사용하고 남은 UserPoint를 응답해주면 되지만,


2. 실패했을 때는 어떤 값을 응답해주고, 로직을 이어나갈 수 있을지 고민해볼 수 있을 것 같다.
    - 실패했을 때는 어떻게 다음 로직을 처리할 수 있을까?

