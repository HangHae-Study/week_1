### **요구 사항**

**API 요구사항**

- PATCH  `/point/{id}/charge` : 포인트를 충전한다.
- PATCH `/point/{id}/use` : 포인트를 사용한다.
- GET `/point/{id}` : 포인트를 조회한다.

**기능 요구사항**

- GET `/point/{id}/histories` : 포인트 내역을 조회한다.
- 잔고가 부족할 경우, 포인트 사용은 실패하여야 합니다.

각 http 메서드에 대한 기능을 완성한다고 했을 때, 컨트롤러 또한 TDD를 기반으로 코드를 작성한다면?

---

### 각 API 별로 반환 요청/응답에 대해서 작성해보기

- PATCH `/point/{id}/charge`
  - RequestBody : Long amount
  - 해당 ID를 가지는 유저의 포인트를 충전한다.
  - 포인트가 충전된 내역을 응답에 담아서 제공한다.


- PATCH `/point/{id}/use` 
  - RequestBody : Long amount
  - 해당 ID 를 가지는 유저의 현재 포인트와, 요청 받은 사용량을 비교한다.
  - 유효한 사용량을 요청했을 경우, 포인트가 사용된 내역을 응답에 담아서 제공한다.
  - 유효하지 않은 사용량을 요청했을 경우, 오류 코드를 응답한다.
  
- GET `/point/{id}`
  - 해당 ID를 가진 유저의 포인트를 조회한다.


- GET `/point/{id}/histories`
  - 해당 ID를 가진 유저의 충전/사용 내역을 조회한다.
  - 충전/사용 내역이 없을 경우 포인트가 0인 기록 하나 가져오기.

---

### 고전파 방식 채택하기

실제 객체를 통해 SpringBoot 서버를 가동하고, DispatchServlet에 접근하여 내부 로직 흐름을 한 바탕 훑을 수 있기 때문

- 의문점
  - 단순히 컨트롤러를 호출한다는것이, 어떻게 통합 테스트가 될 수 있을까?? 요구사항과 로직이 너무 간단하고 이걸 하나의 기능인 단위테스트처럼 느껴지는데..


`HTTP Request -> MockMvc -> DispatcherServlet -> Controller -> Service -> Repository`

@Autowired 로 Controller → Service가 실제 객체로 연결
Table도 실제 Bean

내부 흐름이 실제 애플리케이션의 실행 흐름 그대로 타게 된다

---

### 정상 동작에 대한 테스트 & 발생할 수 없는 동작의 도메인 or 비즈니스 테스트
- 정상 동작에 대한 테스트를 통과시켜 명세하고,
- 부적절한 요청 혹은 발생할 수 없는 경우의 수를 가정하여, 도메인/비즈니스 로직을 검증한다.

ex) 포인트 사용은 포인트가 충분할 때만 사용할 수 있다는 누구나 알고 있는 사실.

-> 요청 시에 적절한 예외 발생과, 실패 응답이 오는지 테스트 코드로 매듭지어보기.


---

### 조회 시 고민 했던 부분

\******
```
  @Test
    void T3_등록되지_않은_유저의_포인트_기록을_조회한다() throws Exception{
        Long userId = 1L;

        mockMvc.perform(get("/point/{id}/histories", userId))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.code").value("SUCCESS"))
                .andExpect(jsonPath("$.data.length()").value(0));
        }
```
1. 길이가 0 이다는 뭔가 내부에 결과가 나올 수 있다는 것을 암시하는 것 같음..


2. 0으로 만들지 말고,, data가 배열로 떨어진다는 사실만 안 채로, 집계한 값이 0인지를 판별한다면?


3. 근데 집계한 값이 0일 경우 포인트를 다 쓴 경우도 있음..


4. 그럼 배열이 떨어진 다는 사실을 알았을 때, 길이를 0으로 판별하는 것이 어찌하였건 테스트를 유효하게 만들 수 있는 조건 같음..


-  배열 안에 뭐가 들어올진 모르고, 배열이라서 길이를 가진다는 것만 아는 것은 ? 화이트 or 블랙인가?
-  배열 안에 데이터가 바뀌더라도, 배열이란 성질은 histories라는 공통의 기록 목록을 도메인으로 가져간다면, 길
-  이를 바라보는 것은 비즈니스에 영향을 받지않고, 도메인에 종속적이므로 블랙박스로 봐도 될듯한데??
  
#### 결론 지어보기  
- 도메인에서, 유저 포인트가 존재한 다음, 포인트 기록이 존재한다라는 사전 요구 명세가 존재한다고 하면


-  `단일 조회, 충전/사용, 기록` 조회에서 유저가 먼저 존재하는지를 보장하기 위해 getPoint를 내부적으로만 호출하게함.
 

- 왜냐면 존재하지 않는 UserPoint에 대한 행위는 이뤄질 수 없으니..
- 테이블 코드에서 UserPoint 반환시 getOrDefault를 통해서 null을 확정적으로 뱉어내지 못하게하는 것을 아는 상태로 하긴 하였음..



- 반면에 이를 이용한다면? 외부 호출에서는 현재 유저가 등록/등록되지 않았건, 신경 쓰지 않고 관련된 유저에 대한 정보만을 가져오는 것을 목적으로 한다. 
  - 등록이 안 되었다면 신규 등록을 먼저 해주고 그다음 행위가 이뤄질 수 있도록 내부 로직에서는 getPoint를 호출 
  - 그렇게 된다면, 외부에서는 없는 유저에 대해서도 신규 유저로 등록을 함과 동시에, 결과를 보여줄 수 있다. 

> 화이트/블랙 박스가 약간 섞인 것 같지만, 유저의 존재/유무 에 따라 나올 수 있는 결과값인
> 
> - `이미 존재하지 않을 때`
>   - 모든 포인트 & 기록 아무것도 없음
> - `이미 존재할 때`
>   - `이미 존재하지 않을 때`를 만족하거나, 하나 이상의 포인트 정보가 존재할 수 있음.

---

### 생각 정리하기
TDD 에서 지향하는 방식이 Bottom-Up ?? 인 것 같지만

API 를 요청하여 하는 컨트롤러 테스트에서, client 가 내부 행위를 모르고 요청을 해도 어떤 경우의 수를 만족할 수 있는 가장 기본적인 조건이 뭐가 있을 까 라는 고민을 할 수 있었음.

요청하는 입장에서의 블랙박스테스트를 암시하는 내부 동작의 안정성을 보장하기 위해 service 클래스의 존재 이유를 보충해주는 ?? 느낌으로 코드가 작성 되었다고 느낌,,

---

### 다음 할일
요청 시, 충전/사용, 그리고 충전/사용 후 포인트 조회 및 포인트 기록 조회의 통합테스트 진행해보기