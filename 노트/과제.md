### **요구 사항**

**API 요구사항**

- PATCH  `/point/{id}/charge` : 포인트를 충전한다.
- PATCH `/point/{id}/use` : 포인트를 사용한다.
- GET `/point/{id}` : 포인트를 조회한다.

**기능 요구사항**

- GET `/point/{id}/histories` : 포인트 내역을 조회한다.
- 잔고가 부족할 경우, 포인트 사용은 실패하여야 합니다.

---

포인트에 대한 CRUD를 진행하게 된다..

TDD를 개발 하기전 기본 구조를 살펴보자면, Controller 클래스와 DB를 나타내는 Table 클래스가 주어짐.

### Table 구조 파악하기

- PointHistory `포인트 충전/사용 내역`
  - ID (히스토리 테이블 식별자)
  - 유저 ID (포인트 충전한 유저 식별자)
  - 충전량 (충전 포인트 금액)
  - 트랜잭션 타입 (충전 : CHARGE, 사용 : USE)
  - 변경 시간 (Milli초)
  

- UserPoint `유저가 가진 포인트`
  - ID : 유저 ID
  - 포인트 : 현재 유저가 가지고 있는 포인트 금액
  - 변경 시간 (Milli초)

1. 유저 -> 포인트 라고 했을 때, 유저가 충전 행위를 한다면?
2. PointHistory에 해당 행위에 대한 데이터를 입력하고, 수행된 최종 결과를 UserPoint의 현재 포인트를 반영하기.

`해당 구조에서 추후에 확장될 수 있을 만한 부분?`
- 음,, 나중에 포인트 사용/충전 기록 등을 조회한다고 했을 때 PointHistoryTable이 사용 될 수도 있을 것이다. 
- 환불 시에 PointHistoryTable을 기반으로, 포인트 사용/감소 여부를 판별할 수도??

> 동시성 제어는 기능을 먼저 완성하고, 진행할 수 있도록 ! 

---

### 충전 방식을 어떻게 진행할까?

1. PointHistory 에서 집계 된 결과에서 마지막 Point를 현재 유저 Point와 비교한다.
2. 그 다음, UserPoint의 point 칼럼에 최신화를 한다?

> 각 테이블 마다 throttle이 존재하는 것을 보았을 때, 서비스에서 저장 요청을 보냈을 때 공유 자원에 대한 접근 또한 신경을 써야할 것 같다.

